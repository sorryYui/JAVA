  自旋锁与自适应锁
  因为在共享数据的锁定状态只会持续很短一段时间，为了这段时间去挂起和恢复线程很不值得。所以在一个线程获得锁的同时另一个线程可以先“稍等一会儿”，但并不放弃处理器执行时间，为了让线程等待，
只须让线程执行一个忙循环（自旋），这就是自旋锁。
  自适应自旋：它可以根据前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果上一次获得了锁，那么下一次就会被认为也会获得锁，进而自旋时间会加长；如果这个锁很少被成功获得，
，避免处理器资源浪费。
  锁消除：拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。
    锁消除是虚拟机自行判断的，开发人员，在编写代码的时候并不用刻意的去规避这些问题，因为有些同步措施都是Java本身自己实现的。
  锁粗化：虚拟机探测到有一系列零碎的操作都对同一个对象加锁，将会加锁的同步范围扩展（粗化）到整个系列的操作外部。
  轻量级锁：轻量级锁是相对于操作系统互斥量来实现的“重量级”锁而言的，但是轻量级锁并不用来替代重量级锁的，它是指在没有多线程竞争的前提下，减少重量级锁使用操作系统互斥量产生的性能消耗。
  HotSpot虚拟机的对象头分为两部分：
    第一部门用户存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age）等。这部分数据的长度咋32位和64位的虚拟机中分别会占用32个或64个比特，官方称它为“Mark
  Word”，它是实现轻量级锁和偏向锁的关键。
    第二部分是用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分用户存储数组长度。


    
