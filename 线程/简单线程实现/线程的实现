  1.主流的操作系统都提供了线程实现，Jav语言则是提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经调用过start()方法且还未结束的java.lang.Thread类的实例就代表这一个线程。
  其实Thread类与大部分的Java类库API有着显著差别，它的所有关键方法都被声明为Native。在Java中，一个Native方法往往就意味着这个方法没有使用或无法使用平台无关的手段来实现
（通常最高效率的手段就是平台相关的手段）。
  1.1 内核线程实现
  使用内核线程实现的方式被称为1:1实现。内核线程（Kernel Levvel Thread，KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，内核通过操纵调度器（Scheduler）对线程进行调度，
并负责将线程的任务映射到各个处理器上。
  其实程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常所讲的线程。这种轻量级进程与内存线程之间1:1的
关系称为一对一的线程模型。
  轻量级进程也具有它的局限性
    由于是基于内核线程实现的，所以各种线程操作（创建、析构及同步），都需要进行系统调用。
    其次，每个轻量级进程都需要一个内核线程的支持，因此需要消耗一定的内核资源，所以一个系统支持轻量级进程的数量是有限的。
1.2 用户线程实现
  使用用户线程实现的方式被称为1:N实现。广义上来讲，一个线程只要不是内核线程，都可以任务是用户线程（User Threa，UT）的一种。从定义上来看轻量级进程不是内核线程也就是属于用户线程，
但是它始终是建立在内核之上的，所以效率会受到限制，并不具备用户线程的优点。
  用户线程的建立、同步、销毁和调度完全咋用户态中完成，不需要内核帮助。如果程序实现得当，不需要切换内核态，因此操作可以是非常快且低消耗的，也能够支持规模更大的线程数量，部分
高性能数据库中的多线程就是由用户线程实现的。
  用户线程的速度快低消耗等优势在于不需要系统内核支援，但是劣势也在于没有内核的支援，所有的线程操作都需要由用户程序自己去处理。这样就会导致线程的一些问题处理起来就很困难，
甚至有些是不可能实现的。
1.3 混合实现
  线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式，被称为N:M实现。用户线程还是完全建立在用户空间中，因此用户线程的创建、
切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，
且用户线程的系统调用要通过轻量级进程来完成，大大降低了整个进程被完全阻塞的风险。
  
  

  
  
