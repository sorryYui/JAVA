因为在 Iterator 接口的核心方法 next（）或者 hasNext （）都是依赖于迭代器当前的迭代的位置。
如果 Collection 实现了 Iterator 接口，肯定会导致集合对象中包含当前迭代位置的数据（指针）。
当集合在不同方法间被传递的时候，由于当前迭代的位置是不可以预置。那么 next 方法的结果会变成不可预知。
这样看使用 Iterable 接口就不会有这样问题，每一次调用都是返回一个新的迭代器。迭代器之间是互不干扰的。
